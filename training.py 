import torch
import torch.optim as optim
import torch.nn as nn
from torch.utils.data import DataLoader
import matplotlib.pyplot as plt
from modules import LesionDetectionModel
from dataset import ISICDataset
import os

# Hyperparameters and configuration
NUM_EPOCHS = 20
BATCH_SIZE = 8
LEARNING_RATE = 0.001
DEVICE = 'cpu' if not torch.cuda.is_available() else 'cuda'  # Set to CPU if CUDA is unavailable
MODEL_SAVE_PATH = 'model_checkpoints'

# Ensuring the model save directory exists
os.makedirs(MODEL_SAVE_PATH, exist_ok=True)

# Loading Model and Data
model = LesionDetectionModel(model_weights='yolov7_weights.pth', device=DEVICE).model
criterion = nn.BCEWithLogitsLoss()  
optimizer = optim.Adam(model.parameters(), lr=LEARNING_RATE)

# Load training and validation datasets
train_dataset = ISICDataset(
    img_dir='/home/groups/comp3710/ISIC2018/ISIC2018_Task1-2_Training_Input_x2',
    annot_dir='/home/groups/comp3710/ISIC2018/ISIC2018_Task1_Training_GroundTruth_x2',
    mode='train'
)
train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)

val_dataset = ISICDataset(
    img_dir='/home/groups/comp3710/ISIC2018/ISIC2018_Task1-2_Test_Input',
    mode='test'
)
val_loader = DataLoader(val_dataset, batch_size=BATCH_SIZE, shuffle=False)

# Lists to store loss and accuracy for plotting
train_losses = []
val_losses = []

def train_one_epoch():
    """
    Train the model for one epoch and return the average loss.
    """
    model.train()
    epoch_loss = 0

    for images, targets in train_loader:
        images = images.to(DEVICE)
        targets = targets.to(DEVICE)

        # Forward pass
        outputs = model(images)
        loss = criterion(outputs, targets)

        # Backward pass and optimization
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        epoch_loss += loss.item()

    avg_loss = epoch_loss / len(train_loader)
    train_losses.append(avg_loss)
    print(f"Training Loss: {avg_loss:.4f}")
    return avg_loss

def validate():
    """
    Validate the model on the validation dataset and return the average loss.
    """
    model.eval()
    val_loss = 0

    with torch.no_grad():
        for images, targets in val_loader:
            images = images.to(DEVICE)
            targets = targets.to(DEVICE)

            # Forward pass
            outputs = model(images)
            loss = criterion(outputs, targets)

            val_loss += loss.item()

    avg_val_loss = val_loss / len(val_loader)
    val_losses.append(avg_val_loss)
    print(f"Validation Loss: {avg_val_loss:.4f}")
    return avg_val_loss

def plot_metrics():
    """
    Plot training and validation losses over epochs.
    """
    plt.figure(figsize=(10, 5))
    plt.plot(train_losses, label="Training Loss")
    plt.plot(val_losses, label="Validation Loss")
    plt.xlabel("Epoch")
    plt.ylabel("Loss")
    plt.legend()
    plt.show()

# Training Loop
for epoch in range(NUM_EPOCHS):
    print(f"Epoch {epoch+1}/{NUM_EPOCHS}")
    train_loss = train_one_epoch()
    val_loss = validate()

    # Saving the model checkpoint after each epoch
    torch.save(model.state_dict(), os.path.join(MODEL_SAVE_PATH, f"model_epoch_{epoch+1}.pth"))

# Plotting the metrics after training
plot_metrics()
